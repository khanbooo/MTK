import lingo/pegcode/driver;
import ds/tree;

Expression ::= Add, Multiply, Subtract, Divide, Negative, Variable, Integer, Equals;

Add(e1: Expression, e2: Expression);
Multiply(e1: Expression, e2: Expression);
Subtract(e1: Expression, e2: Expression);
Divide(e1: Expression, e2: Expression);
Equals(e1: Expression, e2: Expression);
Negative(e1: Expression);
Variable(name: string);
Integer(numerator: int);

parseAST(e: Expression) -> string{
    switch(e){
        Integer(number): {
            i2s(number)
        }
        Add(e1, e2): {
            strGlue(["(", parseAST(e1), " + ", parseAST(e2), ")"], "")
        }
        Multiply(e1, e2): {
            strGlue(["(", parseAST(e1), " * ", parseAST(e2), ")"], "")
        }
        Subtract(e1, e2): {
            strGlue(["(", parseAST(e1), " - ", parseAST(e2), ")"], "")
        }
        Divide(e1, e2): {
            strGlue(["(", parseAST(e1), " / ", parseAST(e2), ")"], "")
        }
        Equals(e1, e2): {
            strGlue(["(", parseAST(e1), " = ", parseAST(e2), ")"], "")
        }
        Negative(e1): {
            strGlue(["(-", parseAST(e1), ")"], "")
        }
        Variable(var): {
            var
        }
    }
}

transformExpression(rules: Tree<Expression, Expression>, e: Expression) -> Expression {
    maybeMatch = lookupTree(rules, e);
    switch (maybeMatch) {
        Some(transformed): transformExpression(rules, transformed);
        None(): {
            switch (e) {
                Add(e1, e2): {
                    newE1 = transformExpression(rules, e1);
                    newE2 = transformExpression(rules, e2);
                    maybeNewMatch = lookupTree(rules, Add(newE1, newE2));
                    switch (maybeNewMatch) {
                        Some(result): transformExpression(rules, result);
                        None(): Add(newE1, newE2);
                    }
                }
                Multiply(e1, e2): {
                    newE1 = transformExpression(rules, e1);
                    newE2 = transformExpression(rules, e2);
                    maybeNewMatch = lookupTree(rules, Multiply(newE1, newE2));
                    switch (maybeNewMatch) {
                        Some(result): transformExpression(rules, result);
                        None(): Multiply(newE1, newE2);
                    }
                }
                Subtract(e1, e2): {
                    newE1 = transformExpression(rules, e1);
                    newE2 = transformExpression(rules, e2);
                    maybeNewMatch = lookupTree(rules, Subtract(newE1, newE2));
                    switch (maybeNewMatch) {
                        Some(result): transformExpression(rules, result);
                        None(): Subtract(newE1, newE2);
                    }
                }
                Divide(e1, e2): {
                    newE1 = transformExpression(rules, e1);
                    newE2 = transformExpression(rules, e2);
                    maybeNewMatch = lookupTree(rules, Divide(newE1, newE2));
                    switch (maybeNewMatch) {
                        Some(result): transformExpression(rules, result);
                        None(): Divide(newE1, newE2);
                    }
                }
                Negative(e1): {
                    newE1 = transformExpression(rules, e1);
                    maybeNewMatch = lookupTree(rules, Negative(newE1));
                    switch (maybeNewMatch) {
                        Some(result): transformExpression(rules, result);
                        None(): Negative(newE1);
                    }
                }
                default: e;
            }
        }
    }
}

init_grammar(){
    compilePegGrammar("#include C:\\flow9\\MTK\\lab10\\arith.lingo");
}

s2expr(str: string) -> Expression{
    parsic(init_grammar(), str, defaultPegActions)
}

main() {
    rules: Tree<Expression, Expression> = fold(
        [
            "((x + y) = 0)",
            "(((c * 6) + 7) = 1)",
            "((1 + a) = (b + c))",
            "(((x * y) + (x * z)) = (x * (y + z)))",
            "(((a / b) * (c / d)) = ((a * c) / (b * d)))",
            "(((x * y) * z) = (x * (y * z)))",
            "(((-x) * (-y)) = (x * y))",
            "(((a / b) / c) = (a / (b * c)))",
            "((x + x) = (y + y))",
            "(((a * b) + (c * d)) = ((d * a) + (b * c)))",
            "(((-x) * y) = (x * (-(-y))))",
            "(((x + y) * (y + x)) = (x * x))",
            "(((a / b) * (b / a)) = (-(-1)))",
            "((x * (y / z)) = ((z * x) / y))",
        ],
        makeTree(),
        \rulesTree: Tree<Expression, Expression>, rule: string -> {
            parsed = s2expr(rule);
            switch(parsed){
                Equals(l, r): setTree(rulesTree, l, r);
                default: rulesTree;
            }
        }
    );
    println("Rules:\n+------------------------------------------------------------------------------------------------------------");
    foldTree(rules, "", \left, right, acc -> {
        println("|" + parseAST(left) + " = " + parseAST(right));
        acc
    });
    println("+------------------------------------------------------------------------------------------------------------");
    examples = [ 
        "((x+y)+z)", 
        "((((a + 1) / (7 * c)) * (((c * 6) + 7) / x)) / ((3 * (a + 1)) / (x * x)))",
        "((((-x) * (-y)) * (z * (-w))) * ((a * b) + (c * d)))",
        "(((x * (y + z)) + (x * (w + v))) / ((a / b) / c))",
        "(((x + x) * (y / z)) * (((a / b) * (b / a)) + ((x + y) * (y + x))))"
    ];
    println("\nExamples:\n+------------------------------------------------------------------------------------------------------------");
    iter( 
        examples, \example -> { 
            expr = s2expr(example);  
            transformed = parseAST(transformExpression(rules, expr));
            println("|Original: " + example);
            println("|Transformed: " + transformed);
            println("+------------------------------------------------------------------------------------------------------------"); 
        } 
    )
}